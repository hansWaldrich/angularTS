"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const run_command_1 = require("../tasks-runner/run-command");
const utils_1 = require("./utils");
const output_1 = require("../utils/output");
const project_graph_1 = require("../core/project-graph");
const file_utils_1 = require("../core/file-utils");
const project_has_target_and_configuration_1 = require("../utils/project-has-target-and-configuration");
const default_reporter_1 = require("../tasks-runner/default-reporter");
function runMany(parsedArgs) {
    const { nxArgs, overrides } = utils_1.splitArgsIntoNxArgsAndOverrides(parsedArgs);
    const projectGraph = project_graph_1.createProjectGraph();
    const projects = projectsToRun(nxArgs, projectGraph);
    const projectMap = {};
    projects.forEach(proj => {
        projectMap[proj.name] = proj;
    });
    const env = file_utils_1.readEnvironment(nxArgs.target, projectMap);
    run_command_1.runCommand(projects, projectGraph, env, nxArgs, overrides, new default_reporter_1.DefaultReporter());
}
exports.runMany = runMany;
function projectsToRun(nxArgs, projectGraph) {
    const allProjects = Object.values(projectGraph.nodes);
    if (nxArgs.all) {
        return runnableForTargetAndConfiguration(allProjects, nxArgs.target, nxArgs.configuration);
    }
    else {
        checkForInvalidProjects(nxArgs, allProjects);
        let selectedProjects = allProjects.filter(p => nxArgs.projects.indexOf(p.name) > -1);
        if (nxArgs.withDeps) {
            selectedProjects = Object.values(project_graph_1.withDeps(projectGraph, selectedProjects).nodes);
        }
        return runnableForTargetAndConfiguration(selectedProjects, nxArgs.target, nxArgs.configuration, true);
    }
}
function checkForInvalidProjects(nxArgs, allProjects) {
    const invalid = nxArgs.projects.filter(name => !allProjects.find(p => p.name === name));
    if (invalid.length !== 0) {
        throw new Error(`Invalid projects: ${invalid.join(', ')}`);
    }
}
function runnableForTargetAndConfiguration(projects, target, configuration, strict = false) {
    const notRunnable = [];
    const runnable = [];
    for (let project of projects) {
        if (project_has_target_and_configuration_1.projectHasTargetAndConfiguration(project, target, configuration)) {
            runnable.push(project);
        }
        else {
            notRunnable.push(project);
        }
    }
    if (strict && notRunnable.length) {
        output_1.output.warn({
            title: `the following do not have configuration for "${target}"`,
            bodyLines: notRunnable.map(p => '- ' + p)
        });
    }
    return runnable;
}
